// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'Config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Config _$ConfigFromJson(Map<String, dynamic> json) {
  return _Config.fromJson(json);
}

/// @nodoc
mixin _$Config {
  /// Whether to add a new line after a closing brace.
  bool get addNewLineAfterClosingBrace => throw _privateConstructorUsedError;

  /// Whether to add a new line after an opening brace.
  bool get addNewLineAfterOpeningBrace => throw _privateConstructorUsedError;

  /// Whether to add a new line after a semicolon.
  bool get addNewLineAfterSemicolon => throw _privateConstructorUsedError;

  /// Whether to add a new line at the end of the text.
  bool get addNewLineAtEndOfText => throw _privateConstructorUsedError;

  /// Whether to add a new line before a closing brace.
  bool get addNewLineBeforeClosingBrace => throw _privateConstructorUsedError;

  /// Whether to add a new line before an opening brace.
  bool get addNewLineBeforeOpeningBrace => throw _privateConstructorUsedError;

  /// The number of spaces to use for indentation. -1 = do not change indentation.
  int get indentationSpacesPerLevel => throw _privateConstructorUsedError;

  /// The maximum number of empty lines to allow. -1 = do not change empty lines.
  int get maxEmptyLines => throw _privateConstructorUsedError;

  /// Whether to remove trailing commas.
  bool get removeTrailingCommas => throw _privateConstructorUsedError;

  /// Serializes this Config to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Config
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ConfigCopyWith<Config> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConfigCopyWith<$Res> {
  factory $ConfigCopyWith(Config value, $Res Function(Config) then) =
      _$ConfigCopyWithImpl<$Res, Config>;
  @useResult
  $Res call(
      {bool addNewLineAfterClosingBrace,
      bool addNewLineAfterOpeningBrace,
      bool addNewLineAfterSemicolon,
      bool addNewLineAtEndOfText,
      bool addNewLineBeforeClosingBrace,
      bool addNewLineBeforeOpeningBrace,
      int indentationSpacesPerLevel,
      int maxEmptyLines,
      bool removeTrailingCommas});
}

/// @nodoc
class _$ConfigCopyWithImpl<$Res, $Val extends Config>
    implements $ConfigCopyWith<$Res> {
  _$ConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Config
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addNewLineAfterClosingBrace = null,
    Object? addNewLineAfterOpeningBrace = null,
    Object? addNewLineAfterSemicolon = null,
    Object? addNewLineAtEndOfText = null,
    Object? addNewLineBeforeClosingBrace = null,
    Object? addNewLineBeforeOpeningBrace = null,
    Object? indentationSpacesPerLevel = null,
    Object? maxEmptyLines = null,
    Object? removeTrailingCommas = null,
  }) {
    return _then(_value.copyWith(
      addNewLineAfterClosingBrace: null == addNewLineAfterClosingBrace
          ? _value.addNewLineAfterClosingBrace
          : addNewLineAfterClosingBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAfterOpeningBrace: null == addNewLineAfterOpeningBrace
          ? _value.addNewLineAfterOpeningBrace
          : addNewLineAfterOpeningBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAfterSemicolon: null == addNewLineAfterSemicolon
          ? _value.addNewLineAfterSemicolon
          : addNewLineAfterSemicolon // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAtEndOfText: null == addNewLineAtEndOfText
          ? _value.addNewLineAtEndOfText
          : addNewLineAtEndOfText // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineBeforeClosingBrace: null == addNewLineBeforeClosingBrace
          ? _value.addNewLineBeforeClosingBrace
          : addNewLineBeforeClosingBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineBeforeOpeningBrace: null == addNewLineBeforeOpeningBrace
          ? _value.addNewLineBeforeOpeningBrace
          : addNewLineBeforeOpeningBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      indentationSpacesPerLevel: null == indentationSpacesPerLevel
          ? _value.indentationSpacesPerLevel
          : indentationSpacesPerLevel // ignore: cast_nullable_to_non_nullable
              as int,
      maxEmptyLines: null == maxEmptyLines
          ? _value.maxEmptyLines
          : maxEmptyLines // ignore: cast_nullable_to_non_nullable
              as int,
      removeTrailingCommas: null == removeTrailingCommas
          ? _value.removeTrailingCommas
          : removeTrailingCommas // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ConfigImplCopyWith<$Res> implements $ConfigCopyWith<$Res> {
  factory _$$ConfigImplCopyWith(
          _$ConfigImpl value, $Res Function(_$ConfigImpl) then) =
      __$$ConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool addNewLineAfterClosingBrace,
      bool addNewLineAfterOpeningBrace,
      bool addNewLineAfterSemicolon,
      bool addNewLineAtEndOfText,
      bool addNewLineBeforeClosingBrace,
      bool addNewLineBeforeOpeningBrace,
      int indentationSpacesPerLevel,
      int maxEmptyLines,
      bool removeTrailingCommas});
}

/// @nodoc
class __$$ConfigImplCopyWithImpl<$Res>
    extends _$ConfigCopyWithImpl<$Res, _$ConfigImpl>
    implements _$$ConfigImplCopyWith<$Res> {
  __$$ConfigImplCopyWithImpl(
      _$ConfigImpl _value, $Res Function(_$ConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of Config
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addNewLineAfterClosingBrace = null,
    Object? addNewLineAfterOpeningBrace = null,
    Object? addNewLineAfterSemicolon = null,
    Object? addNewLineAtEndOfText = null,
    Object? addNewLineBeforeClosingBrace = null,
    Object? addNewLineBeforeOpeningBrace = null,
    Object? indentationSpacesPerLevel = null,
    Object? maxEmptyLines = null,
    Object? removeTrailingCommas = null,
  }) {
    return _then(_$ConfigImpl(
      addNewLineAfterClosingBrace: null == addNewLineAfterClosingBrace
          ? _value.addNewLineAfterClosingBrace
          : addNewLineAfterClosingBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAfterOpeningBrace: null == addNewLineAfterOpeningBrace
          ? _value.addNewLineAfterOpeningBrace
          : addNewLineAfterOpeningBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAfterSemicolon: null == addNewLineAfterSemicolon
          ? _value.addNewLineAfterSemicolon
          : addNewLineAfterSemicolon // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineAtEndOfText: null == addNewLineAtEndOfText
          ? _value.addNewLineAtEndOfText
          : addNewLineAtEndOfText // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineBeforeClosingBrace: null == addNewLineBeforeClosingBrace
          ? _value.addNewLineBeforeClosingBrace
          : addNewLineBeforeClosingBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      addNewLineBeforeOpeningBrace: null == addNewLineBeforeOpeningBrace
          ? _value.addNewLineBeforeOpeningBrace
          : addNewLineBeforeOpeningBrace // ignore: cast_nullable_to_non_nullable
              as bool,
      indentationSpacesPerLevel: null == indentationSpacesPerLevel
          ? _value.indentationSpacesPerLevel
          : indentationSpacesPerLevel // ignore: cast_nullable_to_non_nullable
              as int,
      maxEmptyLines: null == maxEmptyLines
          ? _value.maxEmptyLines
          : maxEmptyLines // ignore: cast_nullable_to_non_nullable
              as int,
      removeTrailingCommas: null == removeTrailingCommas
          ? _value.removeTrailingCommas
          : removeTrailingCommas // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.pascal)
class _$ConfigImpl extends _Config {
  const _$ConfigImpl(
      {required this.addNewLineAfterClosingBrace,
      required this.addNewLineAfterOpeningBrace,
      required this.addNewLineAfterSemicolon,
      required this.addNewLineAtEndOfText,
      required this.addNewLineBeforeClosingBrace,
      required this.addNewLineBeforeOpeningBrace,
      required this.indentationSpacesPerLevel,
      required this.maxEmptyLines,
      required this.removeTrailingCommas})
      : super._();

  factory _$ConfigImpl.fromJson(Map<String, dynamic> json) =>
      _$$ConfigImplFromJson(json);

  /// Whether to add a new line after a closing brace.
  @override
  final bool addNewLineAfterClosingBrace;

  /// Whether to add a new line after an opening brace.
  @override
  final bool addNewLineAfterOpeningBrace;

  /// Whether to add a new line after a semicolon.
  @override
  final bool addNewLineAfterSemicolon;

  /// Whether to add a new line at the end of the text.
  @override
  final bool addNewLineAtEndOfText;

  /// Whether to add a new line before a closing brace.
  @override
  final bool addNewLineBeforeClosingBrace;

  /// Whether to add a new line before an opening brace.
  @override
  final bool addNewLineBeforeOpeningBrace;

  /// The number of spaces to use for indentation. -1 = do not change indentation.
  @override
  final int indentationSpacesPerLevel;

  /// The maximum number of empty lines to allow. -1 = do not change empty lines.
  @override
  final int maxEmptyLines;

  /// Whether to remove trailing commas.
  @override
  final bool removeTrailingCommas;

  @override
  String toString() {
    return 'Config(addNewLineAfterClosingBrace: $addNewLineAfterClosingBrace, addNewLineAfterOpeningBrace: $addNewLineAfterOpeningBrace, addNewLineAfterSemicolon: $addNewLineAfterSemicolon, addNewLineAtEndOfText: $addNewLineAtEndOfText, addNewLineBeforeClosingBrace: $addNewLineBeforeClosingBrace, addNewLineBeforeOpeningBrace: $addNewLineBeforeOpeningBrace, indentationSpacesPerLevel: $indentationSpacesPerLevel, maxEmptyLines: $maxEmptyLines, removeTrailingCommas: $removeTrailingCommas)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfigImpl &&
            (identical(other.addNewLineAfterClosingBrace,
                    addNewLineAfterClosingBrace) ||
                other.addNewLineAfterClosingBrace ==
                    addNewLineAfterClosingBrace) &&
            (identical(other.addNewLineAfterOpeningBrace,
                    addNewLineAfterOpeningBrace) ||
                other.addNewLineAfterOpeningBrace ==
                    addNewLineAfterOpeningBrace) &&
            (identical(
                    other.addNewLineAfterSemicolon, addNewLineAfterSemicolon) ||
                other.addNewLineAfterSemicolon == addNewLineAfterSemicolon) &&
            (identical(other.addNewLineAtEndOfText, addNewLineAtEndOfText) ||
                other.addNewLineAtEndOfText == addNewLineAtEndOfText) &&
            (identical(other.addNewLineBeforeClosingBrace,
                    addNewLineBeforeClosingBrace) ||
                other.addNewLineBeforeClosingBrace ==
                    addNewLineBeforeClosingBrace) &&
            (identical(other.addNewLineBeforeOpeningBrace,
                    addNewLineBeforeOpeningBrace) ||
                other.addNewLineBeforeOpeningBrace ==
                    addNewLineBeforeOpeningBrace) &&
            (identical(other.indentationSpacesPerLevel, indentationSpacesPerLevel) ||
                other.indentationSpacesPerLevel == indentationSpacesPerLevel) &&
            (identical(other.maxEmptyLines, maxEmptyLines) ||
                other.maxEmptyLines == maxEmptyLines) &&
            (identical(other.removeTrailingCommas, removeTrailingCommas) ||
                other.removeTrailingCommas == removeTrailingCommas));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      addNewLineAfterClosingBrace,
      addNewLineAfterOpeningBrace,
      addNewLineAfterSemicolon,
      addNewLineAtEndOfText,
      addNewLineBeforeClosingBrace,
      addNewLineBeforeOpeningBrace,
      indentationSpacesPerLevel,
      maxEmptyLines,
      removeTrailingCommas);

  /// Create a copy of Config
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfigImplCopyWith<_$ConfigImpl> get copyWith =>
      __$$ConfigImplCopyWithImpl<_$ConfigImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ConfigImplToJson(
      this,
    );
  }
}

abstract class _Config extends Config {
  const factory _Config(
      {required final bool addNewLineAfterClosingBrace,
      required final bool addNewLineAfterOpeningBrace,
      required final bool addNewLineAfterSemicolon,
      required final bool addNewLineAtEndOfText,
      required final bool addNewLineBeforeClosingBrace,
      required final bool addNewLineBeforeOpeningBrace,
      required final int indentationSpacesPerLevel,
      required final int maxEmptyLines,
      required final bool removeTrailingCommas}) = _$ConfigImpl;
  const _Config._() : super._();

  factory _Config.fromJson(Map<String, dynamic> json) = _$ConfigImpl.fromJson;

  /// Whether to add a new line after a closing brace.
  @override
  bool get addNewLineAfterClosingBrace;

  /// Whether to add a new line after an opening brace.
  @override
  bool get addNewLineAfterOpeningBrace;

  /// Whether to add a new line after a semicolon.
  @override
  bool get addNewLineAfterSemicolon;

  /// Whether to add a new line at the end of the text.
  @override
  bool get addNewLineAtEndOfText;

  /// Whether to add a new line before a closing brace.
  @override
  bool get addNewLineBeforeClosingBrace;

  /// Whether to add a new line before an opening brace.
  @override
  bool get addNewLineBeforeOpeningBrace;

  /// The number of spaces to use for indentation. -1 = do not change indentation.
  @override
  int get indentationSpacesPerLevel;

  /// The maximum number of empty lines to allow. -1 = do not change empty lines.
  @override
  int get maxEmptyLines;

  /// Whether to remove trailing commas.
  @override
  bool get removeTrailingCommas;

  /// Create a copy of Config
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConfigImplCopyWith<_$ConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
